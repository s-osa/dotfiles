---
description: GitHub Issue を読み取り、調査・実装・解決する
---

# Issue 解決

GitHub Issue を読み取り、調査・実装・解決する。

`/write-issue` で作成した Issue でも、手書きの Issue でも扱える。

## 入力

$ARGUMENTS

## 手順

1. **Issue の読み取り**

   - Issue 番号または URL から内容を取得
   - 関連する既存コメントも確認
   - 関連 Issue やリンクされた PR があれば確認
   - 親イシューかサブイシューかを確認

2. **作業環境の確認**

   現在の作業ディレクトリとブランチを確認する:

   - Git Worktree 環境で呼び出されることがある（worktree の作成自体は呼び出し側の責務）
   - 現在のブランチ、ベースブランチとの差分を把握する
   - **Worktree 内でない場合**: 実行者に確認する（準備漏れの可能性があるため。ただし意図的な場合もあるので、確認のみで続行可）

3. **調査フェーズ**

   - 関連するコードベースを探索
   - 影響範囲を特定
   - 調査結果を Issue にコメントとして残す（何を調べて何がわかったか）

4. **サブイシューの判断と切り出し**

   調査結果を踏まえ、以下の場合はサブイシューに分割する:

   - **3つ以上のステップ・フェーズがある** → 確実に分割
   - **調査・報告でコメントが増えそう** → コンテキストが溢れる前に分割
   - **スコープが広く、1つの Issue で追うと複雑になる** → 分割

   **サブイシュー化する場合:**

   - 親イシューにフェーズ計画をコメントで残す
   - 各フェーズごとにサブイシューを作成し、親イシューに紐づける
   - 実際の作業・調査・報告はサブイシュー側で行う
   - 親イシューには進捗サマリーのみ記載
   - **親イシューはすべてのサブイシューが完了してからクローズする**

5. **方針決定**

   - 実装アプローチを検討
   - 仕様上の不明点は実行者に質問して確認（勝手に決めない）
   - **方針が決まったら、実装を始める前に Issue に方針コメントを書く**（詳細は後述）

6. **実装**

   - 適切な粒度でコミット
   - プロジェクトで用意されているチェック機構（テスト、型チェック、lint、フォーマット、ビルド等）を実行して問題がないことを確認する（具体的なコマンドは CLAUDE.md やプロジェクトの設定から判断）
   - **作業の区切りごとに Issue へ完了報告コメントを書く**（詳細は後述）
   - 開発スタイルについては CLAUDE.md の「開発原則」を遵守する

7. **完了**

   - PR 作成は別途 /submit-pr で行う（このコマンドでは作成しない）
   - 実装が完了したら実行者に報告
   - サブイシューの場合: 親イシューに完了を報告し、他のサブイシューの状況を確認

---

## Issue へのコメント

Issue へのコメントには **2つの種類** があり、それぞれ目的とタイミングが異なる。

### 方針コメント（これからやること）

**タイミング**: 意思決定をしたとき、実装を始める **前**

**目的**:

- 作業が中断しても方針が失われないようにする
- 他の人に引き継げる状態にする

**書く内容**:

- これから何をやるか
- どういうアプローチで進めるか
- 複数の選択肢があった場合、なぜその選択をしたか

**例**:

> これから `UserService` にキャッシュ機能を追加します。
> Redis を使う案もありましたが、今回はスコープを小さくするためインメモリキャッシュで進めます。
>
> 1. キャッシュ層の interface を定義
> 2. InMemoryCache を実装
> 3. UserService に注入

---

### 完了報告コメント（やったこと）

**タイミング**: 作業の区切りごと、実装が完了した **後**

**目的**:

- 作業履歴を記録として残す
- 進捗を可視化する
- 意思決定の経緯を後から追えるようにする

**書く内容**:

- 何を完了したか
- 次に何をやるか（あれば）
- ブロッカーがあれば報告
- **普通と違うこと・変わったことをした場合はその内容と理由**
- **細かい意思決定の記録**（ライブラリ選定、実装方針の選択など）

**例**:

> キャッシュ層の interface 定義と InMemoryCache の実装が完了しました。
>
> 実装中の判断:
>
> - TTL の管理には `lru-cache` と `node-cache` を比較し、TypeScript サポートが充実している `lru-cache` を採用しました
> - キャッシュキーの生成は当初ハッシュ化を検討しましたが、デバッグしやすさを優先して `userId:${id}` 形式にしました
>
> 次は UserService への注入を行います。
